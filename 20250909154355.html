<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2026-01-15 Thu 12:43 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Vibe Coding an Emacs Package: Where It Succeeds and Where It Falls Short</title>
<meta name="author" content="Chang Xiaoduan" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-c:before { content: 'C'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'JavaScript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Vibe Coding an Emacs Package: Where It Succeeds and Where It Falls Short</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org3d681f1">1. Abstract</a></li>
<li><a href="#org2c9d0c5">2. Background</a></li>
<li><a href="#org046d10a">3. Motivation</a></li>
<li><a href="#org18e2e78">4. Game Rules</a></li>
<li><a href="#org52d72ad">5. The Amazement</a></li>
<li><a href="#org9b19cb6">6. The Frustration</a>
<ul>
<li><a href="#orgbab2957">6.1. LLMs' Limits</a></li>
<li><a href="#org280431d">6.2. Lack of Control</a></li>
<li><a href="#org646cce9">6.3. Lack of Growth</a></li>
</ul>
</li>
<li><a href="#org052ee50">7. Reflection</a>
<ul>
<li><a href="#org753baa1">7.1. It May Solve Your Problem</a></li>
<li><a href="#orgf994a94">7.2. It Still Requires Human Intervention</a></li>
<li><a href="#org8c24823">7.3. Programming for Growth and Fun</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
Vibe coding an Emacs package to solve my personalized problem, and
reflections for it.
</p>
<div id="outline-container-org3d681f1" class="outline-2">
<h2 id="org3d681f1"><span class="section-number-2">1.</span> Abstract</h2>
<div class="outline-text-2" id="text-1">
<p>
Vibe coding may solve your problem in the following three scenarios:
</p>

<ol class="org-ol">
<li>You have no idea of programming, but want to develop a program to
solve your personalized problem.</li>
<li>You are a programmer, but are venturing into an unfamiliar domain.</li>
<li>You are developing small-scale or disposable program.</li>
</ol>


<p>
However, it may also make things more difficult when something
goes wrong. Also, if you care about learning through programming, vibe
coding can't help much. LLMs should still be used as a guide and
accelerator, not as a replacement.
</p>
</div>
</div>
<div id="outline-container-org2c9d0c5" class="outline-2">
<h2 id="org2c9d0c5"><span class="section-number-2">2.</span> Background</h2>
<div class="outline-text-2" id="text-2">
<p>
When ChatGPT first launched, I was skeptical about its usefulness for
real programming. At that time, LLMs were weak at logical deduction
and mathematics. They had limited context windows, making handling
large amounts of information difficult. And of course, there was
hallucination &ndash; I still remember the disappointment when a book the
model recommended turned out not to exist.
</p>

<p>
Years have passed, and many of those problems have improved
significantly. More and more people now use LLMs in production-level
engineering(Claude, GitHub Copilot, etc.). Even so, I didn't use LLMs
in my day-to-day work &ndash; until recently.
</p>
</div>
</div>
<div id="outline-container-org046d10a" class="outline-2">
<h2 id="org046d10a"><span class="section-number-2">3.</span> Motivation</h2>
<div class="outline-text-2" id="text-3">
<p>
I use Emacs and <a href="https://www.orgroam.com/">org-roam</a> to implement my personal notes system &ndash; my
<a href="https://zettelkasten.de/overview/">Zettelkasten</a>. Several Emacs packages may serve similar purposes, such
as <a href="https://protesilaos.com/emacs/denote">denote</a> or <a href="https://kaorahi.github.io/howm/">howm</a>. I tried them and settled on org-roam. But I liked a
feature in howm that org-roam lacks: searching a keyword across all
notes and previewing each matching result so we can see the context
and the note it lives in.
</p>

<p>
That sounds like a <code>grep</code> job, and <code>consult-grep</code> should do it. However, I
name my org-roam note files by unique identifiers like
<code>20250910180700.org</code> rather than the title. I do this because note
titles may contain characters not supported by the filesystem, and it
avoids renaming the file if I rename the note title. org-roam's
database has drawbacks, but compared with denote's use of filenames to
hold metadata, I prefer this extra level of indirection.
</p>

<blockquote>
<p>
All problems in computer science can be solved by another level of
indirection except for the problem of too many layers of indirection.
</p>
</blockquote>

<p>
<code>grep</code> and <code>consult-grep</code> were my first attempt, but their results only
show filenames &ndash; meaningless datetime strings in my case &ndash; so I
couldn't tell which note contained the keyword.
</p>

<p>
One benefit of Emacs is that you can (almost) always roll up your
sleeves and scratch your own itch as long as you are
capable. Unfortunately, I am not that capable: I know a bit of Lisp
from reading <i>SICP</i>, but I'd never written any package-level Emacs
Lisp. I read the <code>ripgrep</code> documentation and realized this would require
focused time, not a short wait while a compiler runs.
</p>

<p>
Wait a minute &ndash; what about trying an LLM? I'd been reading about vibe
coding and non-programmers building apps with LLMs. I'd also been
chatting with ChatGPT a lot, which increased my confidence enough that
I wanted to try programming with it.
</p>
</div>
</div>
<div id="outline-container-org18e2e78" class="outline-2">
<h2 id="org18e2e78"><span class="section-number-2">4.</span> Game Rules</h2>
<div class="outline-text-2" id="text-4">
<p>
I followed the Wikipedia definition of vibe coding:
</p>

<blockquote>
<p>
The developer describes a project or task to a large language model
(LLM), which generates code based on the prompt. The developer does
not review or edit the code, but solely uses tools and execution
results to evaluate it and asks the LLM for improvements.
</p>
</blockquote>

<p>
So I would not write, edit, or examine a single line of code. I only
used natural language to describe goals, report errors, and give
feedback based on execution results.
</p>

<p>
The LLM used was ChatGPT 5.
</p>
</div>
</div>
<div id="outline-container-org52d72ad" class="outline-2">
<h2 id="org52d72ad"><span class="section-number-2">5.</span> The Amazement</h2>
<div class="outline-text-2" id="text-5">
<p>
At first, ChatGPT surprised me by understanding my description and
implementing features correctly. It made minor mistakes, but after I
reported an error or incorrect behavior, it quickly found the cause
and produced a patch.
</p>

<p>
In two hours, it implemented the following features from scratch:
</p>

<ol class="org-ol">
<li>Use <code>grep</code> or <code>ripgrep</code> to search a given directory for a keyword and
display results in a dedicated buffer.</li>
<li>When moving the cursor among matches in that buffer, open a preview
window showing the file content at the matched line, with the
matching line and the keyword highlighted.</li>
<li>Group matching results by file, and name each group after the
<code>#+title</code> if the file is an <code>.org</code> file with that keyword; otherwise
fall back to the filename.</li>
</ol>


<p>
I respected the game rules faithfully. Being unfamiliar with Emacs
Lisp and Emacs development, I could hardly improve the code myself. At
that point, I had a viable package that met my initial requirement and
was practically useful. I was so satisfied that I created a GitHub
<a href="https://github.com/drcxd/org-insight/tree/master">repository</a> for it and uploaded the code.
</p>
</div>
</div>
<div id="outline-container-org9b19cb6" class="outline-2">
<h2 id="org9b19cb6"><span class="section-number-2">6.</span> The Frustration</h2>
<div class="outline-text-2" id="text-6">
<p>
Then, I got ambitious and tried to push farther. I wanted to add:
</p>

<ol class="org-ol">
<li>Support for multiple keywords with logical OR/AND operators.</li>
<li>Live preview when typing keywords.</li>
<li>Integration with <a href="https://github.com/minad/vertico">vertico</a>.</li>
</ol>


<p>
Unfortunately, implementing these features proved more difficult than
the first set. I ran into three main sources of frustration.
</p>
</div>
<div id="outline-container-orgbab2957" class="outline-3">
<h3 id="orgbab2957"><span class="section-number-3">6.1.</span> LLMs' Limits</h3>
<div class="outline-text-3" id="text-6-1">
<p>
The first source of frustration is obvious: LLMs can't achieve
everything I asked for, and they sometimes can't recover from their
own errors. The project then stopped there forever.
</p>

<p>
As the program grew more complex, asking the LLM to generate the whole
package led to more syntax errors &ndash; especially mismatched parentheses
in Emacs Lisp. It's impossible to fix such problems without inspecting
the code. Reporting syntax errors back to ChatGPT often didn't help;
it sometimes kept producing syntactically incorrect code while
claiming it was correct. Luckily, I know basic Lisp syntax and could
fix these issues manually. For non-programmers, that kind of fix would
be impossible.
</p>

<p>
The first two additional features did get implemented after about five
hours of iteration, but only with a lot of repetition and
struggle. Most of the time I was just repeating the same problem to
ChatGPT until it finally produced a correct implementation. The third
one never reached a perfect state: behavior was correct but
performance was poor. I asked ChatGPT to improve performance using
timers or asynchronous processes, but it couldn't do so without
breaking existing features. After about two days of fighting, I gave
up and admitted LLMs can't solve every problem &ndash; even ones known to
be solvable.
</p>
</div>
</div>
<div id="outline-container-org280431d" class="outline-3">
<h3 id="org280431d"><span class="section-number-3">6.2.</span> Lack of Control</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The problems that LLMs can't solve led to the second source of
frustration: I can't solve these problems as well.
</p>

<p>
Vibe coding is all good while things go well: LLMs generate working
code and you can ask for features or fixes. But when things go wrong,
the human must check everything to find the cause of the problem. Did
I mis-copy a piece of code? Was the code incorrect? Were the LLM and I
even on the same page? Under the vibe coding rule, I couldn't examine
the code to answer these questions. Even if I broke the rule, working
on a LLM-generated codebase would be much more difficult than building
it from the ground up myself. Convenience came with a price.
</p>

<p>
All I could do was to report that "things were off" and hope the LLM
fixed it next time. It felt like standing by a gambling machine,
hoping for a win. Because I didn't understand the construction of the
machine &ndash; in this case, the LLM and the program it produced &ndash; I was
only counting on sheer luck. Programming attracts me because
programmers have (almost) full control over programs; vibe coding
eliminates it.
</p>
</div>
</div>
<div id="outline-container-org646cce9" class="outline-3">
<h3 id="org646cce9"><span class="section-number-3">6.3.</span> Lack of Growth</h3>
<div class="outline-text-3" id="text-6-3">
<p>
The third, and final source of frustration, is the lack of growth.
</p>

<p>
After I gave up on polishing the third feature to a perfect state and
stopped development. I personally had not grown any more than the one
who started the vibe coding. Vibe coding did yield some useful
outcomes, but I have not learned anything. I was still the one who
knew almost nothing about Emacs package development and I could have
learned something if I read the code generated by LLM. If you are not
a programmer, or don't care about learning programming, or are just
developing a simple, disposable script, this would not be an
issue. However, for anyone who cares about growth and is trying to
build software that serves for a long time, this cannot be ignored.
</p>
</div>
</div>
</div>
<div id="outline-container-org052ee50" class="outline-2">
<h2 id="org052ee50"><span class="section-number-2">7.</span> Reflection</h2>
<div class="outline-text-2" id="text-7">
<p>
Having tried vibe coding, I have several thoughts.
</p>
</div>
<div id="outline-container-org753baa1" class="outline-3">
<h3 id="org753baa1"><span class="section-number-3">7.1.</span> It May Solve Your Problem</h3>
<div class="outline-text-3" id="text-7-1">
<p>
It's amazing that you can instruct an LLM to implement ideas and
iterate using execution feedback. And if the LLM is capable of solving
your problem, then it is fine to have it do so. If you are not a
programmer but are trying to develop software to solve a personalized
problem, do try it. Alternatively, if you are a programmer venturing
into an unfamiliar domain, or are developing a small-scale or
disposable program, it may suit your needs.
</p>
</div>
</div>
<div id="outline-container-orgf994a94" class="outline-3">
<h3 id="orgf994a94"><span class="section-number-3">7.2.</span> It Still Requires Human Intervention</h3>
<div class="outline-text-3" id="text-7-2">
<p>
However, once things go wrong, you may have no way to fix
them. Without knowing the implementation, you can't solve problems the
LLM cannot. A human expert may still be required to solve the problem,
and they may have to work from the ground up again because the
LLM-generated code may be difficult to read, edit, and maintain. This
is a major reason I remain doubtful about fully automatic code
generation. Which is more time-consuming: solving the problem
ourselves, or verifying a solution offered by AI? To me, it feels like
the P vs NP problem.
</p>
</div>
</div>
<div id="outline-container-org8c24823" class="outline-3">
<h3 id="org8c24823"><span class="section-number-3">7.3.</span> Programming for Growth and Fun</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Even if future LLMs become perfect oracles, vibe coding still deprives
us of the fun of solving problems ourselves. It's similar to Go or
chess: even if AI can easily defeat the most competent human player,
we still play for the joy of the activity. (This is one reason we
build AI: to free us from repetitive labor and let us do things for
their own sake.)
</p>

<p>
What's more, although vibe coding produced a usable package that
solves my problem, I didn't grow much during the process. I learned
nothing. This makes me consider LLM-aided coding far more valuable
than pure vibe coding. LLMs help beginners and programmers venturing
into unfamiliar domains get hands-on quickly. We don't need to learn
every basic first: programming is an art you learn by doing. LLM-aided
programming can be an excellent teacher tailored to your
needs. (Though you still have to be cautious about its answers and
instructions!)
</p>

<p>
As a result, I am planning to rewrite the package. This time, I won't
let the LLM write all the code. I may ask for architecture and
targeted implementations, but I'll write &ndash; or at least review &ndash; the
code so I understand how it works and maybe learn a trick or two.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Chang Xiaoduan</p>
<p class="date">Created: 2026-01-15 Thu 12:43</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
